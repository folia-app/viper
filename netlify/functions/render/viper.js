/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/prando/dist/Prando.es.js":
/*!***********************************************!*\
  !*** ./node_modules/prando/dist/Prando.es.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Prando = /** @class */ (function () {\n    // ================================================================================================================\n    // CONSTRUCTOR ----------------------------------------------------------------------------------------------------\n    /**\n     * Generate a new Prando pseudo-random number generator.\n     *\n     * @param seed - A number or string seed that determines which pseudo-random number sequence will be created. Defaults to a random seed based on `Math.random()`.\n     */\n    function Prando(seed) {\n        this._value = NaN;\n        if (typeof seed === \"string\") {\n            // String seed\n            this._seed = this.hashCode(seed);\n        }\n        else if (typeof seed === \"number\") {\n            // Numeric seed\n            this._seed = this.getSafeSeed(seed);\n        }\n        else {\n            // Pseudo-random seed\n            this._seed = this.getSafeSeed(Prando.MIN + Math.floor((Prando.MAX - Prando.MIN) * Math.random()));\n        }\n        this.reset();\n    }\n    // ================================================================================================================\n    // PUBLIC INTERFACE -----------------------------------------------------------------------------------------------\n    /**\n     * Generates a pseudo-random number between a lower (inclusive) and a higher (exclusive) bounds.\n     *\n     * @param min - The minimum number that can be randomly generated.\n     * @param pseudoMax - The maximum number that can be randomly generated (exclusive).\n     * @return The generated pseudo-random number.\n     */\n    Prando.prototype.next = function (min, pseudoMax) {\n        if (min === void 0) { min = 0; }\n        if (pseudoMax === void 0) { pseudoMax = 1; }\n        this.recalculate();\n        return this.map(this._value, Prando.MIN, Prando.MAX, min, pseudoMax);\n    };\n    /**\n     * Generates a pseudo-random integer number in a range (inclusive).\n     *\n     * @param min - The minimum number that can be randomly generated.\n     * @param max - The maximum number that can be randomly generated.\n     * @return The generated pseudo-random number.\n     */\n    Prando.prototype.nextInt = function (min, max) {\n        if (min === void 0) { min = 10; }\n        if (max === void 0) { max = 100; }\n        this.recalculate();\n        return Math.floor(this.map(this._value, Prando.MIN, Prando.MAX, min, max + 1));\n    };\n    /**\n     * Generates a pseudo-random string sequence of a particular length from a specific character range.\n     *\n     * Note: keep in mind that creating a random string sequence does not guarantee uniqueness; there is always a\n     * 1 in (char_length^string_length) chance of collision. For real unique string ids, always check for\n     * pre-existing ids, or employ a robust GUID/UUID generator.\n     *\n     * @param length - Length of the string to be generated.\n     * @param chars - Characters that are used when creating the random string. Defaults to all alphanumeric chars (A-Z, a-z, 0-9).\n     * @return The generated string sequence.\n     */\n    Prando.prototype.nextString = function (length, chars) {\n        if (length === void 0) { length = 16; }\n        if (chars === void 0) { chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; }\n        var str = \"\";\n        while (str.length < length) {\n            str += this.nextChar(chars);\n        }\n        return str;\n    };\n    /**\n     * Generates a pseudo-random string of 1 character specific character range.\n     *\n     * @param chars - Characters that are used when creating the random string. Defaults to all alphanumeric chars (A-Z, a-z, 0-9).\n     * @return The generated character.\n     */\n    Prando.prototype.nextChar = function (chars) {\n        if (chars === void 0) { chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; }\n        return chars.substr(this.nextInt(0, chars.length - 1), 1);\n    };\n    /**\n     * Picks a pseudo-random item from an array. The array is left unmodified.\n     *\n     * Note: keep in mind that while the returned item will be random enough, picking one item from the array at a time\n     * does not guarantee nor imply that a sequence of random non-repeating items will be picked. If you want to\n     * *pick items in a random order* from an array, instead of *pick one random item from an array*, it's best to\n     * apply a *shuffle* transformation to the array instead, then read it linearly.\n     *\n     * @param array - Array of any type containing one or more candidates for random picking.\n     * @return An item from the array.\n     */\n    Prando.prototype.nextArrayItem = function (array) {\n        return array[this.nextInt(0, array.length - 1)];\n    };\n    /**\n     * Generates a pseudo-random boolean.\n     *\n     * @return A value of true or false.\n     */\n    Prando.prototype.nextBoolean = function () {\n        this.recalculate();\n        return this._value > 0.5;\n    };\n    /**\n     * Skips ahead in the sequence of numbers that are being generated. This is equivalent to\n     * calling next() a specified number of times, but faster since it doesn't need to map the\n     * new random numbers to a range and return it.\n     *\n     * @param iterations - The number of items to skip ahead.\n     */\n    Prando.prototype.skip = function (iterations) {\n        if (iterations === void 0) { iterations = 1; }\n        while (iterations-- > 0) {\n            this.recalculate();\n        }\n    };\n    /**\n     * Reset the pseudo-random number sequence back to its starting seed. Further calls to next()\n     * will then produce the same sequence of numbers it had produced before. This is equivalent to\n     * creating a new Prando instance with the same seed as another Prando instance.\n     *\n     * Example:\n     * let rng = new Prando(12345678);\n     * console.log(rng.next()); // 0.6177754114889017\n     * console.log(rng.next()); // 0.5784605181725837\n     * rng.reset();\n     * console.log(rng.next()); // 0.6177754114889017 again\n     * console.log(rng.next()); // 0.5784605181725837 again\n     */\n    Prando.prototype.reset = function () {\n        this._value = this._seed;\n    };\n    // ================================================================================================================\n    // PRIVATE INTERFACE ----------------------------------------------------------------------------------------------\n    Prando.prototype.recalculate = function () {\n        this._value = this.xorshift(this._value);\n    };\n    Prando.prototype.xorshift = function (value) {\n        // Xorshift*32\n        // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n        value ^= value << 13;\n        value ^= value >> 17;\n        value ^= value << 5;\n        return value;\n    };\n    Prando.prototype.map = function (val, minFrom, maxFrom, minTo, maxTo) {\n        return ((val - minFrom) / (maxFrom - minFrom)) * (maxTo - minTo) + minTo;\n    };\n    Prando.prototype.hashCode = function (str) {\n        var hash = 0;\n        if (str) {\n            var l = str.length;\n            for (var i = 0; i < l; i++) {\n                hash = (hash << 5) - hash + str.charCodeAt(i);\n                hash |= 0;\n                hash = this.xorshift(hash);\n            }\n        }\n        return this.getSafeSeed(hash);\n    };\n    Prando.prototype.getSafeSeed = function (seed) {\n        if (seed === 0)\n            return 1;\n        return seed;\n    };\n    Prando.MIN = -2147483648; // Int32 min\n    Prando.MAX = 2147483647; // Int32 max\n    return Prando;\n}());\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Prando);\n\n\n//# sourceURL=webpack://wander/./node_modules/prando/dist/Prando.es.js?");

/***/ }),

/***/ "./src/viper.js":
/*!**********************!*\
  !*** ./src/viper.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Viper\": () => (/* binding */ Viper)\n/* harmony export */ });\n/* harmony import */ var prando__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prando */ \"./node_modules/prando/dist/Prando.es.js\");\n\n// import fs from 'fs'\nlet fs\nclass Viper {\n  constructor(source = \"random-seed\", setting = \"server\") {\n    this.logs = false // false, true, \"verbose\"\n\n\n    this.logs && console.log('constructor')\n    this.logs == \"verbose\" && console.time(\"viper\")\n\n    this.source = source\n    this.rng = new prando__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.source);\n\n    this.setting = setting\n\n    if (this.setting === \"browser\") {\n\n    } else if (this.setting == \"server\") {\n      // so that webpack doesn't try to pack up fs for the browser\n      fs = eval('require')('fs')\n    }\n\n    this.style = \"maskClipRandom\"\n    // style options\n    // 1. maskClipRandom\n    // 1. maskClipSame\n    // 1. randomColor\n    // 1. debug\n    // 1. skeleton\n    // 1. randomGreen\n\n    this.backgroundStyle = \"fourGradient\"\n    // backgroundStyle options\n    // 1. solid\n    // 1. gradient\n    // 1. fourGradient\n    // 1. image\n\n    this.width = 686//343\n    this.maxNumberOfLines = 36\n    this.maxLen = this.width / 12\n    this.strokeW = this.maxLen\n    this.headWidth = this.strokeW * 2\n    this.margin = this.headWidth\n    this.angleDistanceMin = 60\n    this.startPos = \"random\" // TODO: remove?\n    this.strokeStyle = \"random\" // TODO: remove?\n    this.fps = 35\n    this.tweens = 6\n    this.bgColor = \"rgb(226,226,226)\"\n    this.rotationMode = \"center\"\n    this.bgColor = \"rgb(226,226,226)\"\n    this.allLines = []\n    this.allColors = []\n    this.totalLength = 0\n    this.renderedBodies = {}\n    this.totalBodies = 8\n    this.totalHeadsTails = 7\n    this.whichSegment = this.random(0, this.totalBodies)\n    this.bodyOffset = this.random(0, this.totalBodies)\n    this.headTailRandom = this.random(1, this.totalHeadsTails)\n\n    this.headOffset = headOffsets.hasOwnProperty(\"_\" + this.headTailRandom) ? headOffsets[\"_\" + this.headTailRandom] : defaultHeadOffsets\n    this.tailOffset = tailOffsets.hasOwnProperty(\"_\" + this.headTailRandom) ? tailOffsets[\"_\" + this.headTailRandom] : defaultTailOffsets\n  }\n\n  preload() {\n    console.log('viper preload command (only browser)')\n    try {\n      this.logs == \"verbose\" && console.timeLog(\"viper\", \"preload\")\n      this.logs && console.log('preload')\n      this.preloaded = {}\n\n      this.preloaded.tail = window.loadImage('/tail/' + this.headTailRandom + '.png')\n      this.preloaded.head = window.loadImage('/head/' + this.headTailRandom + '.png')\n      this.preloaded.hole = window.loadImage('/holes/1.png')\n      this.preloaded.bodies = []\n      for (var i = 1; i <= this.totalBodies; i++) {\n        this.preloaded.bodies.push(window.loadImage(`/body/${i}.png`))\n      }\n    } catch (preloadError) {\n      console.log({ preloadError })\n    }\n\n  }\n\n  getHeadTailURL(isHead) {\n    console.log('this.headImg', this.headImg)\n    console.log('this.tailImg', this.tailImg)\n    if (!this.headImg || !this.tailImg) {\n      this.headImg = this.headTailRandom + '.png'\n      this.tailImg = this.headImg\n    }\n    const img = isHead ? '/head/' + this.headImg : '/tail/' + this.tailImg\n    const imgURL = process.cwd() + \"/public\" + img\n    if (!fs.existsSync(imgURL)) {\n      throw new Error('head/tail image not found: ' + imgURL)\n    }\n    return imgURL\n  }\n\n  getHoleURL() {\n    if (this.style == \"debug\") {\n      return false\n    }\n    if (!this.holeImg) {\n      this.holeImg = '1.png'\n    }\n    const holeImgURL = process.cwd() + \"/public/holes/\" + this.holeImg\n    if (!fs.existsSync(holeImgURL)) {\n      throw new Error('hole image not found: ' + holeImgURL)\n    }\n    return holeImgURL\n  }\n\n  getBgImgURL() {\n    if (this.backgroundStyle !== \"image\") {\n      return false\n    }\n    if (!this.backgroundImg) {\n      this.backgroundImg = 'bg3_' + this.random(1, 3) + '.png'\n    }\n    const backgroundImageURL = process.cwd() + \"/public/bg/\" + this.backgroundImg\n    if (!fs.existsSync(backgroundImageURL)) {\n      throw new Error('background image not found: ' + backgroundImageURL)\n    }\n    return backgroundImageURL\n  }\n  getBodiesURLs() {\n    if (this.style !== \"maskClipRandom\" && this.style !== \"maskClipSame\") {\n      return false\n    }\n    const bodies = []\n    for (var i = 1; i <= this.totalBodies; i++) {\n      const bodyURL = process.cwd() + `/public/body/${i}.png`\n      if (!fs.existsSync(bodyURL)) {\n        throw new Error('bodyURL image not found: ' + bodyURL)\n      }\n      bodies.push(bodyURL)\n    }\n    return bodies\n  }\n\n  setup(p) {\n    this.logs == \"verbose\" && console.timeLog(\"viper\", \"setup\")\n    this.point = p ? p.point.bind(p) : window.point\n    this.line = p ? p.line.bind(p) : window.line\n    this.fill = p ? p.fill.bind(p) : window.fill\n    this.text = p ? p.text.bind(p) : window.text\n    this.arc = p ? p.arc.bind(p) : window.arc\n    this.rect = p ? p.rect.bind(p) : window.rect\n    this.stroke = p ? p.stroke.bind(p) : window.stroke\n    this.frameRate = p ? p.frameRate.bind(p) : window.frameRate\n    this.strokeWeight = p ? p.strokeWeight.bind(p) : window.strokeWeight\n    this.rectMode = p ? p.rectMode.bind(p) : window.rectMode\n    this.imageMode = p ? p.imageMode.bind(p) : window.imageMode\n    this.angleMode = p ? p.angleMode.bind(p) : window.angleMode\n    this.strokeCap = p ? p.strokeCap.bind(p) : window.strokeCap\n    this.image = p ? p.image.bind(p) : window.image\n    this.background = p ? p.background.bind(p) : window.background\n    this.CORNER = p ? p.CORNER : window.CORNER\n    this.DEGREES = p ? p.DEGREES : window.DEGREES\n    this.ROUND = p ? p.ROUND : window.ROUND\n    this.createCanvas = p ? p.createCanvas.bind(p) : window.createCanvas\n    this.createGraphics = p ? p.createGraphics.bind(p) : window.createGraphics\n    this.dist = p ? p.dist.bind(p) : window.dist\n    this.pop = p ? p.pop.bind(p) : window.pop\n    this.push = p ? p.push.bind(p) : window.push\n    this.translate = p ? p.translate.bind(p) : window.translate\n    this.rotate = p ? p.rotate.bind(p) : window.rotate\n    this.scale = p ? p.scale.bind(p) : window.scale\n    this.noStroke = p ? p.noStroke.bind(p) : window.noStroke\n\n    this.canvas = this.createCanvas(this.width, this.width)\n    if (typeof document !== \"undefined\") {\n      this.canvas.parent('sketch-holder')\n    }\n\n    const { x, y } = this.getStart()\n    this.x = x\n    this.startingX = x\n    this.y = y\n    this.startingY = y\n    this.previousAngle = Math.floor(this.random(0, 360))\n\n    this.frameRate(this.fps);\n    this.strokeWeight(this.strokeW);\n    this.rectMode(this.rotationMode)\n    this.imageMode(this.rotationMode);\n    this.angleMode(this.DEGREES);\n    this.strokeCap(this.ROUND);\n  }\n\n  drawCartesian() {\n\n    this.background(this.bgColor);\n    for (var i = 0; i < this.width; i += 100) {\n      this.strokeWeight(1)\n      this.line(i, 0, i, this.width)\n      this.line(0, i, this.width, i)\n    }\n\n    this.rectMode(this.CORNER)\n    this.strokeWeight(0)\n    this.fill('rgba(255,255,0,0.5)')\n    this.rect(0, 0, this.width, this.margin)\n    this.rect(0, this.margin, this.margin, this.width)\n    this.rect(this.width - this.margin, this.margin, this.margin, this.width)\n    this.rect(this.margin, this.width - this.margin, this.width - this.margin - this.margin, this.margin)\n\n    this.rectMode(this.rotationMode)\n    this.strokeWeight(1)\n\n\n    // line(margin, margin, this.width - margin, margin)\n    // line(this.width - margin, margin, this.width - margin, this.width)\n    // line(this.width - margin, this.width, margin, this.width)\n    // line(margin, this.width, margin, margin)\n\n\n    this.stroke(\"green\")\n    for (var i = 0; i < 12; i++) {\n      var cardinalX = (this.width / 2) + Math.cos(((i * 30)) * Math.PI / 180) * 225\n      var cardinalY = (this.width / 2) + Math.sin(((i * 30)) * Math.PI / 180) * 225\n      this.strokeWeight(0)\n      this.fill(\"green\")\n      this.text(i * 30, cardinalX, cardinalY)\n      this.strokeWeight(1)\n      this.line(this.width / 2, this.width / 2, cardinalX, cardinalY)\n\n    }\n\n    this.stroke(\"red\")\n    this.fill(\"red\")\n    for (var i = 0; i < 8; i++) {\n      var cardinalX = (this.width / 2) + Math.cos(((i * 45)) * Math.PI / 180) * (this.width / 2.5)\n      var cardinalY = (this.width / 2) + Math.sin(((i * 45)) * Math.PI / 180) * (this.width / 2.5)\n      this.strokeWeight(1)\n      this.line(this.width / 2, this.width / 2, cardinalX, cardinalY)\n      this.strokeWeight(0)\n      this.text(i * (360 / 8), cardinalX, cardinalY)\n    }\n  }\n\n  drawBackground(preloaded) {\n    if (this.style == \"debug\") {\n      this.drawCartesian()\n      return\n    }\n\n    switch (this.backgroundStyle) {\n      case \"solid\":\n        this.background(this.bgColor)\n        break;\n      case \"fourGradient\":\n        this.fourColorGradient()\n        break;\n      case \"image\":\n        this.image(\n          preloaded.bgImg,\n          this.width / 2,\n          this.width / 2,\n          this.width,\n          this.width\n        )\n        break;\n      case \"gradient\":\n        throw new Error(\"Simple gradient not transferred from old code\")\n        break;\n      default:\n        throw new Error('Unknown backgroundStyle: ' + this.backgroundStyle);\n    }\n  }\n\n  fourColorGradient() {\n    const resolution = this.width / 5\n    if (!this.savedBG) {\n      const colors = [\n        [this.random(0, 255), this.random(0, 255), this.random(0, 255)],\n        [this.random(0, 255), this.random(0, 255), this.random(0, 255)],\n        [this.random(0, 255), this.random(0, 255), this.random(0, 255)],\n        [this.random(0, 255), this.random(0, 255), this.random(0, 255)]\n      ];\n      this.savedBG = this.createGraphics(this.width, this.width)\n      for (let i = 0; i < resolution; i++) {\n        for (let j = 0; j < resolution; j++) {\n          let s = this.width / resolution;\n          let wx = i * s / this.width\n          let wy = j * s / this.width\n          this.savedBG.noStroke()\n          let c = weightedAvgColor(weightedAvgColor(colors[0], colors[1], wx), weightedAvgColor(colors[3], colors[2], wx), wy)\n          this.savedBG.fill(c)\n          this.savedBG.rect(i * s, j * s, s, s)\n          // this.savedBG.stroke(c)\n          // this.savedBG.strokeWeight(s * 2.9)\n          // this.savedBG.point(i * s, j * s)\n        }\n      }\n    }\n    this.image(this.savedBG, this.width / 2, this.width / 2, this.width, this.width)\n  }\n\n  draw(preloaded) {\n    this.logs == \"verbose\" && console.timeLog(\"viper\", \"draw\")\n    if (typeof preloaded === 'undefined') {\n      preloaded = this.preloaded\n    } else if (typeof this.bodies == \"undefined\") {\n      console.log('here')\n      this.bodies = []\n      for (var i = 0; i < this.totalBodies; i++) {\n        this.bodies.push(preloaded[`body_${i}`])\n      }\n      preloaded.bodies = this.bodies\n    } else {\n      preloaded.bodies = this.bodies\n    }\n    this.totalLength++\n    if (this.setting == \"server\") {\n      this.addAllLines()\n    } else if (this.totalLength % this.tweens == 1) {\n      this.addLine()\n    }\n    this.logs == \"verbose\" && console.timeLog(\"viper\", \"addLine\")\n    this.drawBackground(preloaded)\n    this.logs == \"verbose\" && console.timeLog(\"viper\", \"drawBackground\")\n    this.drawSegments(preloaded)\n    this.logs == \"verbose\" && console.timeLog(\"viper\", \"drawSegments\")\n  }\n\n  drawSegments(preloaded) {\n    for (var i = 0; i < this.allLines.length; i++) {\n      // this is to prevent trying to draw one last segment that starts from startingX and startingY\n      if (this.setting == \"browser\" && i == 0 && this.allLines.length >= this.maxNumberOfLines + 1) {\n        continue\n      }\n      // start new relative translation and rotation\n      // var l = this.allLines[i]\n      var c = this.allColors[i]\n      const { x1, y1, x2, y2, len, ang } = this.getSegmentCoordinates(i)\n\n      this.drawHole(i, preloaded)\n      if (this.style == \"debug\") {\n        this.drawDebug(x1, y1, x2, y2, len, ang, i)\n      } else {\n        switch (this.style) {\n          case (\"maskClipRandom\"):\n            const index = this.allLines.length - i - 1\n            this.whichSegment = (index + this.bodyOffset) % preloaded.bodies.length\n          case (\"maskClipSame\"):\n            this.drawMaskClip(x1, y1, x2, y2, len, ang, c, preloaded)\n            break;\n          case (\"randomColor\"):\n            this.drawRandomColor(x1, y1, x2, y2, c)\n            break;\n          case (\"skeleton\"):\n            break;\n          case (\"randomGreen\"):\n            break;\n          default:\n            throw new Error('Unknown style: ' + this.style);\n        }\n      }\n\n      // draw the tail\n      this.drawTail(x1, y1, x2, y2, i, preloaded)\n\n      // draw the head\n      this.drawHead(x1, y1, x2, y2, i, preloaded)\n\n    }\n  }\n\n  drawHead(x1, y1, x2, y2, i, preloaded) {\n    if (i == this.allLines.length - 1) {\n      const l = this.allLines[i]\n      // stroke(\"rgba(255,0,0,0.1)\")\n      this.noStroke()\n      this.fill(\"rgba(255,0,0,0.5)\")\n      // var headOffset = {\n      //   xFactor: 2,\n      //   yFactor: 2.5\n      // }\n      // console.log({ rotationMode, headOffset, l, head })\n      const headWidth = this.strokeW * 2\n      var calcHeadOffset = {\n        x: headWidth / this.headOffset.xFactor,\n        y: headWidth / this.headOffset.yFactor\n      }\n      if ((l.x1 - l.x2) > (this.width / 80)) {\n        this.push()\n        this.scale(-1, 1)\n        // this.rect((-l.x2) + calcHeadOffset.x, l.y2 - calcHeadOffset.y, headWidth)\n        this.image(preloaded.head, (-x2) + calcHeadOffset.x, y2 - calcHeadOffset.y, headWidth, headWidth);\n        this.pop()\n      } else {\n        // rect(l.x2 + calcHeadOffset.x, l.y2 - calcHeadOffset.y, headWidth)\n        this.image(preloaded.head, x2 + calcHeadOffset.x, y2 - calcHeadOffset.y, headWidth, headWidth);\n      }\n\n    }\n\n  }\n\n  drawTail(x1, y1, x2, y2, i, preloaded) {\n\n    var tailLength = this.strokeW * 1.4\n    var tailWidth = tailLength / 2\n    var calcTailOffset = {\n      x: tailLength / this.tailOffset.xFactor,\n      y: tailWidth * this.tailOffset.yFactor\n    }\n\n    var a = i == 0 && (this.totalLength >= this.maxNumberOfLines) && this.setting == \"server\"\n    var b = i == 1 && (this.totalLength > ((this.maxNumberOfLines + 1) * this.tweens)) && this.setting == \"browser\"\n    if ((a) || (b)) {\n      if ((x1 - x2) > (this.width / 80)) {\n        this.push()\n        this.scale(-1, 1)\n        var tailX = -x1 - calcTailOffset.x // TODO: fix this\n        var tailY = y1 - calcTailOffset.y // TODO: fix this\n        // this.rect(tailX, tailY, tailLength, tailWidth)\n        this.image(preloaded.tail, tailX, tailY, tailLength, tailWidth);\n        this.pop()\n      } else {\n\n        var tailX = x1 - calcTailOffset.x // TODO: fix this\n        var tailY = y1 - calcTailOffset.y // TODO: fix this\n        // this.rect(tailX, tailY, tailLength, tailWidth)\n        this.image(preloaded.tail, tailX, tailY, tailLength, tailWidth);\n      }\n    }\n  }\n\n\n\n  drawMaskClip(x1, y1, x2, y2, len, ang, c, preloaded) {\n    const pic = preloaded.bodies[this.whichSegment]\n    const flip = (x1 - x2) > (this.width / 80)\n    var renderedID = this.whichSegment\n    let imagePattern\n    if (!this.renderedBodies[renderedID]) {\n      var strokeMask = this.createGraphics(len + (this.strokeW * 2), this.strokeW);\n      strokeMask.strokeWeight(this.strokeW)\n      strokeMask.line(this.strokeW / 2, this.strokeW / 2, len + (this.strokeW * 1.5), this.strokeW / 2)\n\n      imagePattern = this.createGraphics(len + (this.strokeW * 2), this.strokeW);\n      imagePattern.background(c)\n      imagePattern.image(pic, 0, -this.strokeW / 2, len + (this.strokeW * 2), this.strokeW * 2)\n\n      imagePattern.loadPixels()\n      strokeMask.loadPixels()\n      for (let j = 0; j < imagePattern.pixels.length; j += 4) {\n        imagePattern.pixels[j + 3] = strokeMask.pixels[j + 3]\n      }\n      imagePattern.updatePixels()\n      this.renderedBodies[renderedID] = imagePattern\n    } else {\n      imagePattern = this.renderedBodies[renderedID]\n    }\n\n    this.push()\n    var xDist = Math.abs(x2 - x1)\n    var yDist = Math.abs(y2 - y1)\n    var fractionOfTotal = 1 / 2\n    var p = {\n      x: x1 + ((x2 < x1 ? -1 : 1) * xDist) * fractionOfTotal,\n      y: y1 + ((y2 < y1 ? -1 : 1) * yDist) * fractionOfTotal\n    }\n    this.translate(p.x, p.y);\n    this.rotate(ang)\n\n    this.push()\n    this.scale(flip ? -1 : 1, flip ? -1 : 1)\n\n    const segmentWeight = this.strokeW / 1.75 // strokeW - ((allLines.length - 1 - i) * diff)\n    this.stroke(\"black\")\n    this.strokeWeight(segmentWeight + (segmentWeight * 0.1))\n    this.line(-len / 2, 0, len / 2, 0)\n\n    this.image(imagePattern, 0, 0, len + segmentWeight, segmentWeight);\n    this.pop()\n    this.pop()\n  }\n\n  drawRandomColor(x1, y1, x2, y2, c) {\n    this.stroke(\"black\")\n    var segmentWeight = this.strokeW / 1.75 // strokeW - ((allLines.length - 1 - i) * diff)\n    this.strokeWeight(segmentWeight + 2)\n    this.line(x1, y1, x2, y2)\n    this.stroke(c)\n    this.strokeWeight(segmentWeight)\n    this.line(x1, y1, x2, y2)\n  }\n\n  drawDebug(x1, y1, x2, y2, len, ang, i) {\n    const l = this.allLines[i]\n    this.stroke(\"black\")\n    var debugLineWeight = this.width / 50\n    this.strokeWeight(debugLineWeight)\n    this.line(x1, y1, x2, y2)\n    this.stroke('rgb(0,255,0)')\n    this.point(x1, y1)\n    this.point(x2, y2)\n    this.stroke('blue')\n    this.strokeWeight(0)\n    this.fill(\"blue\")\n    this.text(`${Math.floor(x1)}, ${Math.floor(y1)} `, x1 + 5, y1 - 5)\n\n\n    for (var j = 0; j < l.failed.length; j++) {\n      const previewX = l.failed[j].newX\n      const previewY = l.failed[j].newY\n      this.stroke(l.failed[j].randomColor)\n      this.strokeWeight(debugLineWeight)\n      this.line(x1, y1, previewX, previewY)\n      this.strokeWeight(0)\n      this.fill(\"blue\")\n      const halfX = x1 > previewX ? x1 - ((x1 - previewX) / 2) : previewX - ((previewX - x1) / 2)\n      const halfY = y1 > previewY ? y1 - ((y1 - previewY) / 2) : previewY - ((previewY - y1) / 2)\n      this.text(j + 1, halfX + 5, halfY);\n      this.strokeWeight(debugLineWeight)\n      this.stroke(\"red\")\n      this.point(previewX, previewY)\n    }\n    this.strokeWeight(0)\n    this.fill(\"rgba(0,0,255,0.4)\")\n    this.arc(x2, y2, len, len, ang - this.angleDistanceMin, ang + this.angleDistanceMin);\n\n  }\n\n  drawHole(i, preloaded) {\n    var a = (i == 0 && this.style !== \"debug\" && this.setting !== \"browser\")\n    var b = (i == 0 && this.style !== \"debug\" && this.setting == \"browser\")\n      ||\n      (i == 1 && this.totalLength > ((this.maxNumberOfLines) * this.tweens) && this.style !== \"debug\" && this.setting == \"browser\")\n    if (a || b) {\n      var holeWidth = this.strokeW * 2\n      this.image(preloaded.hole, this.startingX - (this.strokeW / 4), this.startingY - (this.strokeW / 2), holeWidth, holeWidth);\n    }\n  }\n\n  getSegmentCoordinates(i) {\n    const l = this.allLines[i]\n    let x1, y1, x2, y2, len, ang\n    if (this.setting == \"browser\") {\n      let lastLine\n      let offsetTilNextSegment = this.totalLength % this.tweens\n      if (i == 0) {\n        lastLine = {\n          x1: this.startingX,\n          y1: this.startingY,\n          x2: this.startingX,\n          y2: this.startingY\n        }\n      } else {\n        lastLine = this.allLines[i - 1]\n      }\n\n      // console.log('lastLine')\n      // console.log(`ll.x1: ${lastLine.x1}, ll.y1: ${lastLine.y1}, ll.x2: ${lastLine.x2}, ll.y2: ${lastLine.y2}`)\n\n      // normally we draw each line x1,y1 to x2,y2\n      // x1,y1 is the end of the previous line\n      // x2,y2 is the end of the current line\n      x1 = offsetTilNextSegment == 0 ? l.x1 : ((l.x1 - lastLine.x1) * (offsetTilNextSegment / this.tweens)) + lastLine.x1\n      y1 = offsetTilNextSegment == 0 ? l.y1 : ((l.y1 - lastLine.y1) * (offsetTilNextSegment / this.tweens)) + lastLine.y1\n      x2 = offsetTilNextSegment == 0 ? l.x2 : ((l.x2 - lastLine.x2) * (offsetTilNextSegment / this.tweens)) + lastLine.x2\n      y2 = offsetTilNextSegment == 0 ? l.y2 : ((l.y2 - lastLine.y2) * (offsetTilNextSegment / this.tweens)) + lastLine.y2\n\n      // len is the distance between x1,y1 and x2,y2\n      len = this.dist(x1, y1, x2, y2)\n      ang = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n    } else {\n      x1 = l.x1\n      x2 = l.x2\n      y1 = l.y1\n      y2 = l.y2\n      len = l.len\n      ang = l.ang\n    }\n    return { x1, y1, x2, y2, len, ang }\n  }\n\n\n\n  addLine() {\n    const angResults = this.wander()\n    const ang = angResults.angle\n\n    const x2 = this.x + Math.cos(ang * Math.PI / 180) * this.maxLen\n    const y2 = this.y + Math.sin(ang * Math.PI / 180) * this.maxLen\n    const c = [this.random(0, 255), this.random(0, 255), this.random(0, 255)]\n\n    const newLine = {\n      x1: this.x,\n      y1: this.y,\n      x2: x2,\n      y2: y2,\n      ang: ang,\n      len: this.maxLen,\n      failed: angResults.failed,\n      maskedImage: null\n    }\n    this.allLines.push(newLine)\n    this.allColors.unshift(c)\n\n    if (this.allLines.length > this.maxNumberOfLines + 1) {\n      this.allLines.shift()\n      this.allColors.shift()\n    }\n\n    this.previousAngle = ang\n    this.x = x2\n    this.y = y2\n  }\n\n  addAllLines() {\n    for (let i = 0; i < this.maxNumberOfLines; i++) {\n      this.addLine()\n      this.totalLength++\n    }\n  }\n\n  random(min = 0, max = 1) {\n    return this.rng.nextInt(min, max)\n  }\n\n  getStart() {\n    const min = this.margin\n    const max = this.width - this.margin\n    const x = this.random(min, max)\n    const y = this.random(min, max)\n    return { x, y }\n  }\n\n  // wander is the heart of the algorithm\n  // it takes the previous line's end point and angle and returns a new angle\n  // the new angle is within the maxDifferenceBetweenAngles of the previous angle\n  // the new angle is also within the margin of the canvas\n  // if the new angle doesn't work, it tries again, increasing until the worst case scenario which is 180 degrees\n  // it's been optimized to find a solution 100% of the time in under \n  wander() {\n    const previousX = this.x\n    const previousY = this.y\n    const previousAngle = this.previousAngle\n    const lineLength = this.maxLen\n    const width = this.width\n    const margin = this.margin\n    const maxDifferenceBetweenAngles = this.angleDistanceMin\n\n    // maxDifferenceBetweenAngles cannot be greater than 180\n    if (maxDifferenceBetweenAngles > 180) throw new Error('maxDifferenceBetweenAngles cannot be greater than 180')\n\n    // get a random amount to change the angle by\n    var angleDelta = this.random(0, maxDifferenceBetweenAngles)\n    // this ensures that the search for a working angle doesn't always start by adding to the angle (turning clockwise)\n    if (angleDelta <= (maxDifferenceBetweenAngles / 2)) {\n      angleDelta = angleDelta * -1\n    }\n\n    // this ensures that if the first solution doesn't work, the next one isn't always the first solution through addition (turn clockwise)\n    var isOddAdditionalRandom = 1\n    // if angleDelta is odd, then isOddAdditionalRandom will be -1\n    if (angleDelta % 2 == 0) {\n      isOddAdditionalRandom = -1\n    }\n\n    // keeping track of the failed attempts allows you to debug\n    var failed = []\n    // changeByAmount is the amount that the angle will be changed by each time. It should remain lower than maxDifferenceBetweenAngles\n    var changeByAmount = 45//(maxDifferenceBetweenAngles) - 1\n    var anglesInACircle = 360\n    for (var i = 0; i < anglesInACircle / changeByAmount; i++) {\n      // first try, i == 0 so isOdd is false\n      // second try, i == 1 so isOdd is true\n      // third try, i == 2 so isOdd is false\n      // fourth try, i == 3 so isOdd is true\n      var iIsOdd = i % 2 == 0 ? false : true\n\n      // first try, addOrRemove should be 1\n      // second try, addOrRemove should be -1\n      // third try, addOrRemove should be 1\n      // fourth try, addOrRemove should be -1\n      var addOrRemove = iIsOdd ? -1 : 1\n\n      // first try, i == 0 and timesTried should be 0\n      // second try, i == 1 and timesTried should be 1\n      // third try, i == 2 and timesTried should be 1\n      // fourth try, i == 3 and timesTried should be 2\n      var timesTried = Math.ceil(i / 2)\n\n      // first try should be the angleDelta\n      // second try should be the angleDelta + changeByAmount\n      // third try should be the angleDelta - changeByAmount\n      // fourth try should be the angleDelta + (2 * changeByAmount)\n      var changeBy = angleDelta + (timesTried * changeByAmount) * -1 * addOrRemove\n\n      // actually applying the change to the angle should also be randomly additional or subtractive\n      var newAngle = previousAngle + (changeBy * isOddAdditionalRandom)\n      newAngle = newAngle < 0 ? 360 + newAngle : (newAngle > 360 ? newAngle % 360 : newAngle)\n\n      // check if the angle works with that distance\n      var newX = Math.floor(previousX + Math.cos(newAngle * Math.PI / 180) * (lineLength))\n      var newY = Math.floor(previousY + Math.sin(newAngle * Math.PI / 180) * (lineLength))\n      // if it does, return the new point\n      if (!outSideCanvas(newX, newY, this.width, this.margin)) {\n        return { x: newX, y: newY, tries: i + 1, angle: newAngle, failed }\n      }\n      var randomColor = `rgb(${Math.ceil(this.random(0, 255))}, ${Math.ceil(this.random(0, 255))}, ${Math.ceil(this.random(0, 255))})`\n      failed.push({ changeBy, newAngle, newX, newY, randomColor })\n    }\n    console.log({ previousX, previousY, previousAngle, maxDifferenceBetweenAngles, lineLength, width, margin })\n    console.log({ failed })\n    throw new Error(`Unable to find a new point from(${previousX}, ${previousY}, ${previousAngle})`)\n  }\n\n}\n\nfunction outSideCanvas(x, y, width, margin) {\n  // note, this doesn't account for the margin of the bottom\n  if (x < margin || x > width - margin || y < margin || y > width) {\n    return true\n  }\n  return false\n}\n\n\nfunction weightedAvgColor(a, b, w) {\n  let x, y, z;\n  w = w + (w - 0.5) * 0.45;  // Messed with the weight to get the color densities to match the image https://stackoverflow.com/questions/11482349/four-point-gradient-in-ios\n  if (w > 1) w = 0.99;\n  if (a[0] != b[0]) {\n    x = a[0] + (b[0] - a[0]) * w;\n  }\n  else {\n    x = a[0];\n  }\n\n  if (a[1] != b[1]) {\n    y = a[1] + (b[1] - a[1]) * w;\n  }\n  else {\n    y = a[1];\n  }\n\n  if (a[2] != b[2]) {\n    z = a[2] + (b[2] - a[2]) * w;\n  }\n  else {\n    z = a[2];\n  }\n  return [x, y, z]\n}\n\nasync function loadFn(fn, content) {\n  return Promise.resolve(fn(content))\n}\n\nconst defaultHeadOffsets = {\n  xFactor: 2,\n  yFactor: 2.5\n}\n\nconst headOffsets = {\n  _1: {\n    xFactor: 1.8,\n    yFactor: 2.3\n  },\n  _2: {\n    xFactor: 2.5,\n    yFactor: 2.3\n  },\n  _3: {\n    xFactor: 2.2,\n    yFactor: 2.2\n  },\n  _4: {\n    xFactor: 2.2,\n    yFactor: 2.2\n  },\n  _5: {\n    xFactor: 2.3,\n    yFactor: 2.4\n  },\n  _6: {\n    xFactor: 2.5,\n    yFactor: 1.9\n  },\n  _7: {\n    xFactor: 1.9,\n    yFactor: 3\n  },\n  _8: {\n    xFactor: 2,\n    yFactor: 2\n  },\n  _9: {\n    xFactor: 3.3,\n    yFactor: 2.6\n  }\n}\n\nconst defaultTailOffsets = {\n  xFactor: 2,\n  yFactor: 0\n}\n\nconst tailOffsets = {\n  _1: {\n    xFactor: 2.1,\n    yFactor: 0.05\n  },\n  _3: {\n    xFactor: 1.9,\n    yFactor: 0.2\n  },\n  _4: {\n    xFactor: 1.8,\n    yFactor: -0.2\n  },\n  _5: {\n    xFactor: 1.8,\n    yFactor: 0\n  },\n  _6: {\n    xFactor: 1.7,\n    yFactor: 0.3\n  },\n  _7: {\n    xFactor: 1.8,\n    yFactor: 0.2\n  }\n}\n\n// if(typeof exports === 'undefined'){\n//   var exports = this['sampleModule'] = {};\n// }\n\n\n\n//# sourceURL=webpack://wander/./src/viper.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/viper.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});