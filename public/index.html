<html>

<head>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.js"></script>
  <script src="./wander.js"></script>
</head>

<body>
  <div id="sketch-holder">
  </div>
</body>

<script>
  // on click #sketch-holder, set stop to !stop
  document.getElementById('sketch-holder').addEventListener('click', () => {
    stop = !stop
  })

  var stop = false
  var x, y, width, minLen, maxLen, strokeW, margin,
    angleDistanceMin, startPos, previousAng,
    strokeStyle, totalLength = 0, allLines = [], allColors = [], presetLines = [], presetColors = [],
    img, dropShadowColor, dropShadowLoop, dropShadowOffset,
    headOffset, headOffsets, tailOffset, tailOffsets,
    totalHeads = 9, totalBodies = 8, totalTails = 7, totalBG = 3, totalPatterns = 8,
    tails = [], heads = [], bodies = [], bgs = [], patterns = [], whichSegment,
    head, tail, bgImg, makeMask, hole,
    imagePath = "http://localhost:8888",
    matchTail = true, firstSet = false


  var createCoordinates = () => {
    var allPoints = [{ x: margin, y: margin }]
    startingX = margin
    startingY = margin
    x = startingX
    y = startingY
    worableArea = width - (margin * 2)
    for (var i = 0; i < width * 5; i += width / 10) {
      var odd = Math.floor(i / worableArea) % 2 == 0
      var x = odd ? i % worableArea : worableArea - (i % worableArea)
      var y = Math.floor(i / worableArea) * (width / 10)
      allPoints.push({ x: x + margin, y: y + margin })
      presetColors.push(color(random(255), random(255), random(255)))
    }
    allPoints.forEach((p, i) => {
      if (i > 0) {
        presetLines.push({
          x1: allPoints[i - 1].x,
          y1: allPoints[i - 1].y,
          x2: p.x,
          y2: p.y,
          len: distanceCalc(allPoints[i - 1].x, allPoints[i - 1].y, p.x, p.y)
        })
      }
    })
  }

  function distanceCalc(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))
  }

  function setParams() {
    width = 800
    maxLen = width / 12
    minLen = maxLen
    strokeW = width / 12 //minLen / 1
    headWidth = strokeW * 1.8
    margin = headWidth
    maxNumberOfLines = 24
    angleDistanceMin = 60
    startPos = "random" // "bottom", "center", "random"
    strokeStyle = "random" // "randomGreen", "random", "gettingDarker", "none"
    fps = 6
    bgColor = "rgb(226,226,226)"
    try {
      rotationMode = CENTER
    } catch (e) {
      // console.log(e)
    }
    debug = false
    animated = false
    makeLoop = false
    keepRunning = true
    dropShadowColor = "rgba(0, 0, 0, 0.008)"
    dropShadowOffset = {
      x: 15,
      y: 15
    }
    drawings = true
    includeShadow = false
    startingX = false //margin
    startingY = false // width - margin
    startingAng = false //135
    egg = false
    bg = "image" // "solid", "gradient", "image"
    dropShadowLoop = bg == "solid" ? 20 : 50
    shouldSave = false
    taperEnd = false
    skipToEnd = false
    dontCross = false
    bodyOffset = Math.floor(Math.random() * totalBodies)
    makeMask = true
    dontClearBG = false
    preset = false
    sameSegment = true
    // bodies = patterns

    // which Segment is random selection from allLines
    whichSegment = Math.floor(random(0, bodies.length))

  }
  function setup() {
    if (!firstSet) {
      setParams()
    }
    firstSet = true
    configureCanvas()
    if (preset) {
      createCoordinates()
    }
    // img.mask(mask)
  }

  var defaultHeadOffsets = {
    xFactor: 2,
    yFactor: 2.5
  }

  headOffsets = {
    _1: {
      xFactor: 1.8,
      yFactor: 2.3
    },
    _2: {
      xFactor: 10,
      yFactor: 2.1
    },
    _3: {
      xFactor: 2.2,
      yFactor: 2.2
    },
    _4: {
      xFactor: 2.2,
      yFactor: 2.2
    },
    _5: {
      xFactor: 2.3,
      yFactor: 2.4
    },
    _6: {
      xFactor: 2.5,
      yFactor: 1.9
    },
    _7: {
      xFactor: 1.9,
      yFactor: 3
    },
    _8: {
      xFactor: 2,
      yFactor: 2
    },
    _9: {
      xFactor: 3.3,
      yFactor: 2.6
    }
  }

  var defaultTailOffsets = {
    xFactor: 2,
    yFactor: 0
  }

  tailOffsets = {
    _1: {
      xFactor: 2.1,
      yFactor: 0.05
    },
    _3: {
      xFactor: 1.9,
      yFactor: 0.2
    },
    _4: {
      xFactor: 1.8,
      yFactor: -0.2
    },
    _5: {
      xFactor: 1.8,
      yFactor: 0
    },
    _6: {
      xFactor: 1.7,
      yFactor: 0.3
    },
    _7: {
      xFactor: 1.8,
      yFactor: 0.2
    }
  }

  function preload() {
    var tailRandom = Math.ceil(Math.random() * totalTails)
    var headRandom;
    tail = loadImage(imagePath + `/tail/${tailRandom}.png`)
    if (tailRandom < 7 && matchTail) {
      headRandom = tailRandom
      head = loadImage(imagePath + `/head/${tailRandom}.png`)
    } else {
      headRandom = totalTails + Math.floor(Math.random() * (totalHeads - totalTails + 1))
      console.log(headRandom)
      head = loadImage(imagePath + `/head/${headRandom}.png`)
    }

    headOffset = headOffsets.hasOwnProperty("_" + headRandom) ? headOffsets["_" + headRandom] : defaultHeadOffsets
    tailOffset = tailOffsets.hasOwnProperty("_" + tailRandom) ? tailOffsets["_" + tailRandom] : defaultTailOffsets

    bgImg = loadImage(imagePath + `/bg/${Math.ceil(Math.random() * totalBG)}.jpeg`)

    for (var i = 1; i <= totalBodies; i++) {
      bodies.push(loadImage(imagePath + `/body/${i}.png`))
    }
    // for (var i = 1; i <= totalBG; i++) {
    //   bgs.push(loadImage(imagePath + `/bg/${i}.jpeg`)) // uses jpeg instead of png
    // }
    for (var i = 1; i <= totalTails; i++) {
      tails.push(loadImage(imagePath + `/tail/${i}.png`))
    }
    for (var i = 1; i <= totalPatterns; i++) {
      patterns.push(loadImage(imagePath + `/pattern/${i}.jpg`)) // uses jpg
    }

    // mask = loadImage(imagePath + '/black-semi-opaque.png');
    // mask = loadImage(imagePath + '/rounded.png');
    mask = loadImage(imagePath + '/rounded.png');


    hole = loadImage(imagePath + "/holes/1.png")
  }

  function configureCanvas() {
    try {
      canvas = createCanvas(width, width);
      canvas.parent('sketch-holder');
    } catch (e) {
      // console.log(e)
    }

    switch (startPos) {
      case "bottom":
        x = width / 2;
        y = width - (margin / 2);
        break;
      case "center":
        x = width / 2;
        y = width / 2;
        break;
      case "random":
        var boundary = width - (margin * 2)
        x = Math.floor(Math.random() * boundary) + margin
        y = Math.floor(Math.random() * boundary) + margin
    }
    if (startingAng) {
      previousAng = startingAng
    } else {
      startingAng = 0
    }

    if (startingX) {
      x = startingX
    } else {
      startingX = x
    }
    if (startingY) {
      y = startingY
    } else {
      startingY = y
    }
    try {
      frameRate(fps);

      strokeWeight(strokeW);
      rectMode(rotationMode)
      imageMode(rotationMode);
      angleMode(DEGREES);
      strokeCap(ROUND);
      addBackground()
    } catch (e) {
      // console.log(e)
    }
  }


  const Y_AXIS = 1;
  const X_AXIS = 2;
  let b1, b2, c1, c2;

  function setGradient(x, y, w, h, c1, c2, axis) {
    noFill();

    if (axis === Y_AXIS) {
      // Top to bottom gradient
      for (let i = y; i <= y + h; i++) {
        let inter = map(i, y, y + h, 0, 1);
        let c = lerpColor(c1, c2, inter);
        stroke(c);
        line(x, i, x + w, i);
      }
    } else if (axis === X_AXIS) {
      // Left to right gradient
      for (let i = x; i <= x + w; i++) {
        let inter = map(i, x, x + w, 0, 1);
        let c = lerpColor(c1, c2, inter);
        stroke(c);
        line(i, y, i, y + h);
      }
    }
  }

  function addBackground() {
    if (debug) {
      addCartesian()
    } else if (bg == "solid") {
      background(bgColor);
    } else if (bg == "gradient") {
      b1 = color(255);
      b2 = color(0);
      setGradient(0, 0, width, height, b1, b2, Y_AXIS);
    } else if (bg == "image") {
      image(bgImg, width / 2, width / 2, width, width);
    } else {
      throw new Error(`Background type ${bg} not supported`)
    }
    // ellipse(width / 2, width / 2, width / 4, width / 3,)
    // scale(this.scalar);
    if (egg) {
      fill("rgb(249,229,188)")
      stroke("black")
      strokeWeight(2)
      var direction = totalLength % 12
      var tilt = totalLength % 6
      tilt -= 3
      tilt *= 5
      tilt = direction >= 6 ? tilt * -1 : tilt
      push()
      translate(width / 2, (width / 2) + 100);
      rotate(tilt)
      beginShape();
      vertex(0, -100);
      scale(2)
      bezierVertex(25, -100, 40, -65, 40, -40);
      bezierVertex(40, -15, 25, 0, 0, 0);
      bezierVertex(-25, 0, -40, -15, -40, -40);
      bezierVertex(-40, -65, -25, -100, 0, -100);
      endShape();
      pop()

      push()
      fill("black")
      translate(width / 2, (width / 2) + 100);
      rotate(tilt)
      star(0, -100, 25, 50, 5)
      pop()
    }

  }

  function star(x, y, radius1, radius2, npoints) {
    angleMode(RADIANS);

    let angle = TWO_PI / npoints;
    let halfAngle = angle / 2.0;
    beginShape();
    for (let a = 0; a < TWO_PI; a += angle) {
      let sx = x + cos(a) * radius2;
      let sy = y + sin(a) * radius2;
      vertex(sx, sy);
      sx = x + cos(a + halfAngle) * radius1;
      sy = y + sin(a + halfAngle) * radius1;
      vertex(sx, sy);
    }
    endShape(CLOSE);
    angleMode(DEGREES);
  }
  function addCartesian() {
    background(bgColor);
    textSize(16);
    strokeWeight(3)
    stroke(0)
    // line(width / 2, 0, width / 2, width)
    // line(0, width / 2, width, width / 2)
    strokeWeight(5)
    for (var i = 0; i < width; i += 100) {
      line(i, 0, i, width)
      stroke(11)
      strokeWeight(0)
      strokeWeight(1)
      line(0, i, width, i)
    }
    line(margin, margin, width - margin, margin)
    line(width - margin, margin, width - margin, width)
    line(width - margin, width, margin, width)
    line(margin, width, margin, margin)

    // stroke("green")
    // for (var i = 0; i < 12; i++) {
    //   var cardinalX = (width / 2) + Math.cos(((i * 30)) * Math.PI / 180) * 225
    //   var cardinalY = (width / 2) + Math.sin(((i * 30)) * Math.PI / 180) * 225
    //   strokeWeight(0)
    //   fill("green")
    //   text(i * 30, cardinalX, cardinalY)
    //   strokeWeight(1)
    //   line(width / 2, width / 2, cardinalX, cardinalY)

    // }

    // stroke("red")
    // for (var i = 0; i < 8; i++) {
    //   var cardinalX = (width / 2) + Math.cos(((i * 45)) * Math.PI / 180) * 500
    //   var cardinalY = (width / 2) + Math.sin(((i * 45)) * Math.PI / 180) * 500
    //   line(width / 2, width / 2, cardinalX, cardinalY)
    // }

  }

  var saved = false
  var printedDone = false
  async function draw() {
    if (stop) return
    totalLength++
    if (!keepRunning) {
      if (totalLength > (maxNumberOfLines * (animated ? 2 : 1))) {
        if (makeLoop) {
          totalLength = 0
          allLines = []
          allColors = []

          x = startingX
          y = startingY
          previousAng = startingAng
          addBackground()
        }
        var datetime = new Date().toISOString().replace(/:/g, '-');
        if (!saved && shouldSave) {
          saved = true
          setTimeout(() => {
            saveCanvas(canvas, 'viper-' + datetime, 'jpg');
          }, 5000)
        }
        if (!printedDone) {
          console.log("Done at " + datetime)
          printedDone = true
        }
        return
      }
    }

    // if totalLength is odd
    // if (totalLength % 2 || !animated) {
    addLine()
    //   if (animated && !drawings) {
    //     drawMidLines()
    //   }
    // } else {
    //   drawLines()
    // }

    if (totalLength != (maxNumberOfLines * (animated ? 2 : 1)) && skipToEnd) {
      return
    }
    if (!dontClearBG) {
      addBackground()
    }

    if (!animated) {
      if (!drawings) {
        drawLines()
      } else {
        // drawLines()
        if (debug) {
          drawDebug()
        }
        drawImgs()
        // drawLines()

      }
    }
    // shouldSave image

  }
  function setStrokeColor() {
    var c
    switch (strokeStyle) {
      case "random":
        c = [random(255), random(255), random(255)]
        break;
      case "gettingDarker":
        var percentageOfTotal255 = ((totalLength / maxNumberOfLines) * 255)
        c = [percentageOfTotal255, percentageOfTotal255, percentageOfTotal255]
        break;
      case "randomGreen":
        c = [0, random(100, 200), 0]
        break;
      default:
        c = bgColor
    }
    return c
  }

  function getShadowWeight(i) {
    var foo = strokeW * (0.5) + (i * 1)
    return foo
  }


  function startDropShadow(i) {
    strokeCap(SQUARE);
    strokeWeight(getShadowWeight(i));
    stroke(dropShadowColor);
    strokeJoin(ROUND);
    beginShape();
  }

  function endDropShadow() {
    endShape();
    strokeCap(ROUND);
  }

  function addDropShadowTip(l) {
    for (var i = 1; i < dropShadowLoop; i++) {
      strokeWeight(0)
      fill(dropShadowColor)
      var diameter = getShadowWeight(i)
      arc(l.x1 + dropShadowOffset.x, l.y1 + dropShadowOffset.y, diameter, diameter, l.ang + 90, l.ang - 90);
      noFill()

      startDropShadow(i)
      vertex(l.x1 + dropShadowOffset.x, l.y1 + dropShadowOffset.y)
      vertex(((l.x1 + l.x2) / 2) + dropShadowOffset.x, ((l.y1 + l.y2) / 2) + dropShadowOffset.y);
      endShape();
    }
  }

  function addDropShadowEnd(l) {
    for (var i = 1; i < dropShadowLoop; i++) {

      startDropShadow(i)
      // strokeCap(ROUND);
      vertex(((l.x1 + l.x2) / 2) + dropShadowOffset.x, ((l.y1 + l.y2) / 2) + dropShadowOffset.y);
      vertex(l.x2 + dropShadowOffset.x, l.y2 + dropShadowOffset.y);
      endDropShadow()

      strokeWeight(0)
      fill(dropShadowColor)
      var diameter = getShadowWeight(i)
      arc(l.x2 + dropShadowOffset.x, l.y2 + dropShadowOffset.y, diameter, diameter, l.ang - 90, l.ang + 90);
      noFill()
    }
  }

  function addDropShadow2(l, l2) {
    for (var i = 0; i < dropShadowLoop; i++) {
      startDropShadow(i)

      vertex(((l.x1 + l.x2) / 2) + dropShadowOffset.x, ((l.y1 + l.y2) / 2) + dropShadowOffset.y);
      vertex(l.x2 + dropShadowOffset.x, l.y2 + dropShadowOffset.y);
      vertex(((l2.x1 + l2.x2) / 2) + dropShadowOffset.x, ((l2.y1 + l2.y2) / 2) + dropShadowOffset.y);

      endDropShadow()
    }
  }

  function addDropShadow(i, allLines) {
    var l = allLines[i]
    if (i == 0) {
      addDropShadowTip(l)
    }
    if (i != allLines.length - 1) {
      addDropShadow2(allLines[i], allLines[i + 1])
    }
    if (i == allLines.length - 1) {
      addDropShadowEnd(l)
    }
    // offset = 0
    // for (var i = 1; i < 30; i++) {
    //   console.log('dropShadowColor')
    //   stroke(dropShadowColor)
    //   strokeWeight(strokeW + i)
    //   line(l.x1 + offset, l.y1 + offset, l.x2 + offset, l.y2 + offset)
    // }

  }

  function drawDebug() {
    for (var i = 0; i < allLines.length; i++) {
      var l = allLines[i]

      try {
        strokeWeight(0)
        fill("rgba(0,0,255,0.4)")
        // arc(l.x1, l.y1, 40, 40, l.ang - angleDistanceMin, l.ang + angleDistanceMin);
      } catch (e) { }

      stroke("red")
      strokeWeight(4)
      line(l.x1, l.y1, l.x2, l.y2)
      strokeWeight(10)
      stroke('red')
      point(l.x1, l.y1)
      stroke('blue')
      strokeWeight(0)
      fill("blue")
      text(`${Math.floor(l.x1)}, ${Math.floor(l.y1)} `, l.x1 + 5, l.y1 - 5)


      for (var j = 0; j < l.failed.length; j++) {
        previewX = l.failed[j].newX
        previewY = l.failed[j].newY
        stroke(l.failed[j].randomColor)
        strokeWeight(4)
        line(l.x1, l.y1, previewX, previewY)
        strokeWeight(0)
        fill("blue")
        halfX = l.x1 > previewX ? l.x1 - ((l.x1 - previewX) / 2) : previewX - ((previewX - l.x1) / 2)
        halfY = l.y1 > previewY ? l.y1 - ((l.y1 - previewY) / 2) : previewY - ((previewY - l.y1) / 2)
        text(j + 1, halfX + 5, halfY);
      }
      try {
        strokeWeight(0)
        fill("rgba(0,0,255,0.4)")
        arc(l.x2, l.y2, 40, 40, l.ang - angleDistanceMin, l.ang + angleDistanceMin);
      } catch (e) { }
    }
  }

  function drawImgs() {
    for (var i = 0; i < allLines.length; i++) {
      // start new relative translation and rotation
      var l = allLines[i]
      if (includeShadow) {
        addDropShadow(i, allLines)
      }

      // get the index of the item in allLines as the opposite of the position in the array
      var index = allLines.length - i - 1
      whichSegment = sameSegment ? whichSegment : (index + bodyOffset) % bodies.length
      pic = bodies[whichSegment]
      var flip = index % 4
      switch (flip) {
        case 0:
          flip1 = true
          flip2 = true
          break;
        case 1:
          flip1 = false
          flip2 = true
          break;
        case 2:
          flip1 = true
          flip2 = false
          break;
        case 3:
          flip1 = false
          flip2 = false
          break;
      }

      if (taperEnd) {
        var widthSteps = 1.5
        var changeEvery = Math.floor(allLines.length / widthSteps)
        var endWidth = strokeW / 1.5
        var currentWidth = (endWidth * (Math.ceil(i / changeEvery)))
        if (currentWidth <= 0) {
          currentWidth = endWidth
        }
      } else {
        currentWidth = strokeW
      }

      if (i == 0 && !debug) {
        // draw the hole
        var holeWidth = currentWidth * 2.5
        image(hole, startingX - (currentWidth / 8), startingY - (currentWidth / 4), holeWidth, holeWidth);

      }

      if (!debug) {

        var imagePattern
        if (makeMask) {
          var strokeMask = createGraphics(l.len + (currentWidth * 2), currentWidth);
          strokeMask.strokeWeight(currentWidth)
          strokeMask.line(currentWidth / 2, currentWidth / 2, l.len + (currentWidth * 1.5), currentWidth / 2)


          imagePattern = createGraphics(l.len + (currentWidth * 2), currentWidth);
          imagePattern.background(allColors[i])
          // imagePattern.image(pic, 0, 0, l.len + (currentWidth * 2), currentWidth)
          imagePattern.image(pic, 0, -currentWidth / 2, l.len + (currentWidth * 2), currentWidth * 2)

          imagePattern.loadPixels()
          strokeMask.loadPixels()
          for (let j = 0; j < imagePattern.pixels.length; j += 4) {
            imagePattern.pixels[j + 3] = strokeMask.pixels[j + 3]
          }
          imagePattern.updatePixels()
        } else {
          imagePattern = pic
        }

        push()
        var xDist = Math.abs(l.x2 - l.x1)
        var yDist = Math.abs(l.y2 - l.y1)
        var fractionOfTotal = 1 / 2
        var p = {
          x: l.x1 + ((l.x2 < l.x1 ? -1 : 1) * xDist) * fractionOfTotal,
          y: l.y1 + ((l.y2 < l.y1 ? -1 : 1) * yDist) * fractionOfTotal
        }
        translate(p.x, p.y);
        rotate(l.ang)

        push()
        scale(flip1 ? -1 : 1, flip2 ? -1 : 1)
        // tint(segColor)
        // tint(allColors[i][0], allColors[i][1], allColors[i][2])
        var segmentWeight, addToLength
        if (makeMask) {
          segmentWeight = currentWidth / 1.75 // strokeW - ((allLines.length - 1 - i) * diff)
          stroke("black")
          strokeWeight(segmentWeight + (segmentWeight * 0.1))
          line(-l.len / 2, 0, l.len / 2, 0)
          addToLength = segmentWeight
        } else {
          segmentWeight = currentWidth / 1.2
          addToLength = segmentWeight / 2
        }
        image(imagePattern, 0, 0, l.len + addToLength, segmentWeight);
        pop()


        // revert to original translation and rotation
        pop()
      }

      // draw the head
      if (i == allLines.length - 1) {
        // stroke("rgba(255,0,0,0.1)")
        noStroke()
        fill("rgba(255,0,0,0.1)")
        // var headOffset = {
        //   xFactor: 2,
        //   yFactor: 2.5
        // }

        var calcHeadOffset = {
          x: headWidth / headOffset.xFactor,
          y: headWidth / headOffset.yFactor
        }
        if (l.x2 < l.x1) {//} && (l.x1 - l.x2) > margin) {
          push()
          scale(-1, 1)
          // rect((-l.x2) + calcHeadOffset.x, l.y2 - calcHeadOffset.y, headWidth)
          image(head, (-l.x2) + calcHeadOffset.x, l.y2 - calcHeadOffset.y, headWidth, headWidth);
          pop()
        } else {
          // rect(l.x2 + calcHeadOffset.x, l.y2 - calcHeadOffset.y, headWidth)
          image(head, l.x2 + calcHeadOffset.x, l.y2 - calcHeadOffset.y, headWidth, headWidth);
        }
      }

      var tailLength = currentWidth * 1.4
      var tailWidth = tailLength / 2
      var calcTailOffset = {
        x: tailLength / tailOffset.xFactor,
        y: tailWidth * tailOffset.yFactor
      }

      // draw the tail
      if (i == 0 && keepRunning && allLines.length >= maxNumberOfLines) {

        if (l.x2 < l.x1) {//} && (l.x1 - l.x2) > margin) {
          push()
          scale(-1, 1)
          image(tail, -l.x1 - calcTailOffset.x, l.y1 - calcTailOffset.y, tailLength, tailWidth);
          pop()
        } else {
          image(tail, l.x1 - calcTailOffset.x, l.y1 - calcTailOffset.y, tailLength, tailWidth);
        }
      }

      // // draw the shaddow on the entrance of the egg
      // if (i == 0) {
      //   console.log('draw centershadow')
      //   for (var j = 0; j < dropShadowLoop * 2; j++) {
      //     stroke('rgba(0,0,0,0.2)')
      //     strokeWeight(j * 1.5)
      //     point(width / 2, width / 2)
      //   }
      // }
    }
  }

  function drawMidLines() {
    for (var i = 0; i < allLines.length; i++) {
      var x1, y1, x2, y2
      var l = allLines[i]
      if (i == 0) {
        x1 = l.x1
        y1 = l.y1
        x2 = (l.x1 + l.x2) / 2
        y2 = (l.y1 + l.y2) / 2
      } else {
        var prevL = allLines[i - 1]
        x1 = (prevL.x1 + prevL.x2) / 2
        y1 = (prevL.y1 + prevL.y2) / 2

        x2 = (l.x1 + l.x2) / 2
        y2 = (l.y1 + l.y2) / 2
      }
      var c = allColors[i]
      stroke("rgba(0, 0, 0, 1)")
      strokeWeight(strokeW + 2)
      line(x1, y1, x2, y2)
      if (!debug) {
        // stroke(c)
        // strokeWeight(strokeW)
        // line(x1, y1, x2, y2)
      }

    }
  }

  function drawLines() {
    // var diff = Math.floor(strokeW / allLines.length)

    for (var i = 0; i < allLines.length; i++) {
      var l = allLines[i]
      var c = allColors[i]
      if (!debug && includeShadow) {
        addDropShadow(i, allLines)
      }
      stroke("black")
      // make segmentWeight a fraction of the length of allLines

      var segmentWeight = strokeW / 1.75 // strokeW - ((allLines.length - 1 - i) * diff)
      strokeWeight(segmentWeight + 2)
      line(l.x1, l.y1, l.x2, l.y2)
      if (!debug) {
        stroke(c)
        strokeWeight(segmentWeight)
        line(l.x1, l.y1, l.x2, l.y2)
      }
    }
  }


  function addLine() {
    if (presetLines.length > 0) {
      var l = presetLines.shift()
      allLines.push(l)
      allColors.unshift(setStrokeColor())
      return
    }
    if (!previousAng) {
      previousAng = Math.floor(Math.random() * 360)
    }
    var len = pickLength()
    var angResults = returnNextPoint(x, y, previousAng, angleDistanceMin, len, width, margin)
    var ang = angResults.angle
    // var ang = pickAngle(x, y, angleDistanceMin)
    x2 = x + Math.cos(ang * Math.PI / 180) * len
    y2 = y + Math.sin(ang * Math.PI / 180) * len
    c = setStrokeColor()


    var newLine = {
      x1: x,
      y1: y,
      x2: x2,
      y2: y2,
      ang: ang,
      len: len,
      failed: angResults.failed
    }
    allLines.push(newLine)
    allColors.unshift(c)

    if (allLines.length > maxNumberOfLines) {
      allLines.shift()
      allColors.shift()
    }

    previousAng = ang
    x = x2
    y = y2
  }

  function pickLength() {
    return Math.ceil(random(minLen - 1, maxLen))
  }


  function sleep(millisecondsDuration) {
    return new Promise((resolve) => {
      setTimeout(resolve, millisecondsDuration);
    })
  }
  // returns true if the line from (a,b)->(c,d) intersects with (p,q)->(r,s)
  function intersects(a, b, c, d, p, q, r, s) {
    var det, gamma, lambda;
    det = (c - a) * (s - q) - (r - p) * (d - b);
    if (det === 0) {
      return false;
    } else {
      lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
      gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
      return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
    }
  };

  // pickAngle
  /*
  The pickAngle function is the heart of the algorithm.
  It takes the current x and y coordinates and returns an angle that is within the angleDistanceMin of the previous angle.
  It then checks whether this new angle is within the bounds of the canvas.
  If it is not, it will try to find an angle that is within the bounds of the canvas.
  It does this by adding increments to the new angle until it reaches the angleDistanceMin.
  If it still can't find an angle it will repeat the process, only this time removing increments from the new angle.
  If this still doesn't work it will try increasing the angleDistanceMin and doing both adding and removing again.
  If this still doens't work it will continue to increase the angleDistanceMin and repeat the attempts until angleDistanceMin is 180.
  If it still does not find a working angle by then it will throw an Error and print the coordinates that it was unable to succeed from.
  */


  function testAlgo() {
    totalTries = 0
    totalFailures = 0
    attempts = 1_000_000
    var testWidth = 800
    var testLineLength = testWidth / 10
    var testMargin = (testWidth / 10) * 1.55

    var testStartingX = testWidth - testMargin
    var testStartingY = testWidth - testMargin
    var testPreviousAngle = 45

    var maxTries = 0

    var testMaxDifferenceBetweenAngles = 30
    for (var i = 0; i < attempts; i++) {
      testStartingX = Math.floor(Math.random() * (testWidth - (testMargin * 2))) + testMargin
      testStartingY = Math.floor(Math.random() * (testWidth - (testMargin * 2))) + testMargin
      testPreviousAngle = Math.floor(Math.random() * 360)
      try {
        var results = returnNextPoint(testStartingX, testStartingY, testPreviousAngle, testMaxDifferenceBetweenAngles, testLineLength, testWidth, testMargin)
        totalTries += results.tries
        if (results.tries > maxTries) maxTries = results.tries
      } catch (e) {
        totalFailures += 1
      }
    }
    console.log(`----new algo-----`)
    console.log(`Max tries: ${maxTries}`)
    console.log(`Average tries: ${totalTries / attempts}`)
    console.log(`Failures: ${totalFailures} (${Math.floor((totalFailures / attempts) * 100)}%)`)
  }

  function testOld() {
    var maxTries = 0
    var totalTries = 0
    var totalFailures = 0
    var attempts = 1_000_000
    for (var i = 0; i < attempts; i++) {
      firstSet = false
      setup()
      previousAng = Math.floor(Math.random() * 360)
      try {
        var results = pickAngle(x, y, angleDistanceMin)
        totalTries += results.attempts
        if (results.attempts > maxTries) maxTries = results.attempts
      } catch (e) {
        console.log({ e })
        totalFailures += 1
      }
    }
    console.log(`----old algo-----`)
    console.log(`Max tries: ${maxTries}`)
    console.log(`Average tries: ${totalTries / attempts}`)
    console.log(`Failures: ${totalFailures} (${Math.floor((totalFailures / attempts) * 100)}%)`)
  }
  // testOld()
  // testAlgo()

  function returnNextPoint(previousX, previousY, previousAngle, maxDifferenceBetweenAngles, lineLength, width, margin) {

    // maxDifferenceBetweenAngles cannot be greater than 180
    if (maxDifferenceBetweenAngles > 180) throw new Error('maxDifferenceBetweenAngles cannot be greater than 180')

    // get a random amount to change the angle by
    var angleDelta = Math.floor(Math.random() * maxDifferenceBetweenAngles)

    // this ensures that the search for a working angle doesn't always start by adding to the angle (turning clockwise)
    if (angleDelta <= (maxDifferenceBetweenAngles / 2)) {
      angleDelta = angleDelta * -1
    }

    // this ensures that if the first solution doesn't work, the next one isn't always the first solution through addition (turn clockwise)
    var isOddAdditionalRandom = 1
    // if angleDelta is odd, then isOddAdditionalRandom will be -1
    if (angleDelta % 2 == 0) {
      isOddAdditionalRandom = -1
    }

    // keeping track of the failed attempts allows you to debug
    var failed = []
    // changeByAmount is the amount that the angle will be changed by each time. It should remain lower than maxDifferenceBetweenAngles
    var changeByAmount = maxDifferenceBetweenAngles - 1
    var anglesInACircle = 360
    for (var i = 0; i < anglesInACircle / changeByAmount; i++) {
      // first try, i == 0 so isOdd is false
      // second try, i == 1 so isOdd is true
      // third try, i == 2 so isOdd is false
      // fourth try, i == 3 so isOdd is true
      var iIsOdd = i % 2 == 0 ? false : true

      // first try, addOrRemove should be 1
      // second try, addOrRemove should be -1
      // third try, addOrRemove should be 1
      // fourth try, addOrRemove should be -1
      var addOrRemove = (iIsOdd ? -1 : 1)

      // first try, i == 0 and timesTried should be 0
      // second try, i == 1 and timesTried should be 1
      // third try, i == 2 and timesTried should be 1
      // fourth try, i == 3 and timesTried should be 2
      var timesTried = Math.ceil(i / 2)

      // first try should be the angleDelta
      // second try should be the angleDelta + changeByAmount
      // third try should be the angleDelta - changeByAmount
      // fourth try should be the angleDelta + (2 * changeByAmount)
      var changeBy = angleDelta + (timesTried * changeByAmount) * -1 * addOrRemove

      // actually applying the change to the angle should also be randomly additional or subtractive
      var newAngle = previousAngle + (changeBy * isOddAdditionalRandom)
      newAngle = newAngle < 0 ? 360 + newAngle : (newAngle > 360 ? newAngle % 360 : newAngle)

      // check if the angle works with that distance
      var newX = Math.floor(previousX + Math.cos(newAngle * Math.PI / 180) * (lineLength))
      var newY = Math.floor(previousY + Math.sin(newAngle * Math.PI / 180) * (lineLength))
      // if it does, return the new point
      if (!outSideCanvas(newX, newY, width, margin)) {
        return { x: newX, y: newY, tries: i + 1, angle: newAngle, failed }
      }
      var randomColor = `rgb(${Math.ceil(random(0, 255))}, ${Math.ceil(random(0, 255))}, ${Math.ceil(random(0, 255))})`
      failed.push({ changeBy, newAngle, newX, newY, randomColor })
    }
    console.log({ previousX, previousY, previousAngle, maxDifferenceBetweenAngles, lineLength, width, margin })
    console.log({ failed })
    throw new Error(`Unable to find a new point from(${previousX}, ${previousY}, ${previousAngle})`)
  }

  function outSideCanvas(x, y, width, margin) {
    if (x < margin || x > width - margin || y < margin || y > width) {//- margin) {
      return true
    }
    return false
  }

  function random(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min
  }


  function pickAngle(x1, y1, _angleDistanceMin) {
    var attempts = 0
    if (isNaN(_angleDistanceMin)) {
      _angleDistanceMin = 0
    } else if (_angleDistanceMin > 180) {
      _angleDistanceMin = 180
    }
    var startingAngle
    if (previousAng) {
      var delta = Math.ceil(random(-1 * _angleDistanceMin, _angleDistanceMin))
      if (debug) {
        console.log({ x1, y1, previousAng, _angleDistanceMin, delta })
      }
      var startingAngle = previousAng + delta
      startingAngle = startingAngle < 0 ? 360 + startingAngle : (startingAngle > 360 ? startingAngle % 360 : startingAngle)
      if (debug) {
        try {
          strokeWeight(0)
          fill("rgba(0,0,255,0.2)")
          arc(x1, y1, 40, 40, previousAng - _angleDistanceMin, previousAng + _angleDistanceMin);
        } catch (e) { }
      }
      try {
        fill("black")
      } catch (e) { }

    } else {
      startingAngle = Math.ceil(random(0, 360))
      // startingAngle = Math.ceil(random(0, 12)) * 30

    }

    // try to find an angle that is not too close to the previous one
    var foundAng = false

    // if the eventual angle (ang) is unacceptable, we will attempt to increase or decrease
    // the ang until an acceptable one is found  
    // increaseLoop determines whether we increase or decrease and has a 50/50 chance of being true or false
    var increaseLoop = startingAngle > 180
    if (debug) {
      var strokeColor = `rgb(${Math.ceil(random(0, 255))}, ${Math.ceil(random(0, 255))}, ${Math.ceil(random(0, 255))})`
    }
    let loopThroughResults1 = loopThroughAngles(x1, y1, previousAng, startingAngle, increaseLoop, _angleDistanceMin, strokeColor)
    attempts += loopThroughResults1.attempts
    if (debug) {
      console.log(`loopThroughResults1 ${loopThroughResults1.foundAng ? 'succeeded' : 'failed'}(ang = ${loopThroughResults1.ang})`)
    }
    if (!loopThroughResults1.foundAng) {
      increaseLoop = !increaseLoop
      loopThroughResults2 = loopThroughAngles(x1, y1, previousAng, startingAngle, increaseLoop, _angleDistanceMin, strokeColor)
      attempts += loopThroughResults2.attempts
      if (debug) {
        console.log(`loopThroughResults2 ${loopThroughResults2.foundAng ? 'succeeded' : 'failed'}(ang = ${loopThroughResults2.ang})`)
      }
      ang = loopThroughResults2.ang
      foundAng = loopThroughResults2.foundAng
    } else {
      ang = loopThroughResults1.ang
      foundAng = loopThroughResults1.foundAng
    }

    if (!foundAng) {
      if (parseInt(_angleDistanceMin) >= 180) {
        console.log({ x, y, previousAng })
        makeLoop = false
        throw new Error('INCREASED TO MAX AND STILL NO SUITABLE ANG')
      } else {
        // incrementBy should be increased maximum 3 times and on the last time equal 180 regardless of original angleDistanceMin
        var incrementBy = (180 - angleDistanceMin) / 3
        var results = pickAngle(x1, y1, (parseInt(_angleDistanceMin) + (incrementBy)))
        ang = results.ang
        attempts += results.attempts
      }
    }
    return { ang, attempts }
  }

  function loopThroughAngles(x1, y1, previousAng, startingAngle, increaseLoop, _angleDistanceMin, strokeColor) {

    var attempts = 0
    var ang
    var foundAng = false
    var k = 0
    var incrementBy = 33
    var breakIntoNumberOfChunks = 6

    var incrementUntil = 180
    // if prevoiusAng exists
    if (!isNaN(previousAng)) {

      if (increaseLoop) {
        _fromAngle = startingAngle
        _toAngle = previousAng + _angleDistanceMin
        // incrementUntil = getAngleDifference(startingAngle, previousAng + _angleDistanceMin)
      } else {
        _fromAngle = previousAng - _angleDistanceMin
        _toAngle = startingAngle
        // incrementUntil = getAngleDifference(previousAng - _angleDistanceMin, startingAngle)
      }
      if (_toAngle > _fromAngle) {
        incrementUntil = _toAngle - _fromAngle
      } else {
        incrementUntil = getAngleDifference(_fromAngle, _toAngle)
      }

      if (debug) {
        console.log(`angleDifference between ${_fromAngle} and ${_toAngle} is ${incrementUntil}`)
      }
      incrementBy = Math.ceil(incrementUntil / breakIntoNumberOfChunks)
      if (debug) {
        console.log(`when ${increaseLoop ? 'incrementing, add' : 'decrementing, remove'} ${incrementBy} to / from ${startingAngle} until ${incrementUntil} have been ${increaseLoop ? 'added' : 'removed'}} `)
      }
    } else {
      if (debug) {
        console.log(`first angle attempt is ${startingAngle} `)
      }
    }

    for (var i = 0; i < incrementUntil; i += incrementBy) {
      attempts++
      k++
      if (k > breakIntoNumberOfChunks) {
        console.log({ k })
        throw new Error("too many attempts")
      }
      if (increaseLoop) {
        ang = (startingAngle + i) % 360
      } else {
        ang = (startingAngle - i)
        if (ang < 0) {
          ang = 360 + ang
        }
      }

      // get the new position assuming maxLen is used
      var previewX = x1 + Math.cos(ang * Math.PI / 180) * (maxLen)
      var previewY = y1 + Math.sin(ang * Math.PI / 180) * (maxLen)
      if (dontCross) {
        var intersectsWithAnyOtherLine = false
        for (var j = 0; j < allLines.length; j++) {
          var curLine = allLines[j]

          var intersect = intersects(x, y, previewX, previewY, curLine.x1, curLine.y1, curLine.x2, curLine.y2)

          if (intersect) {
            intersectsWithAnyOtherLine = true
            // break out of the j makeLoop
            break
          }
        }
        if (intersectsWithAnyOtherLine) {
          if (debug) {
            console.log(`intersectsWithAnyOtherLine ${intersectsWithAnyOtherLine} at ${ang} `)
          }
          continue
        }
      }

      if (debug) {
        console.log(`attempt ang ${ang} by changing by ${i} `)
        strokeWeight(5)
        stroke('red')
        point(x1, y1)
        stroke('blue')
        strokeWeight(0)
        fill("blue")
        text(`${Math.floor(x1)}, ${Math.floor(y1)} `, x1 + 5, y1 - 5)
        stroke(strokeColor)
        strokeWeight(2)
        line(x1, y1, previewX, previewY)
        strokeWeight(0)
        fill("blue")
        halfX = x1 > previewX ? x1 - ((x1 - previewX) / 2) : previewX - ((previewX - x1) / 2)
        halfY = y1 > previewY ? y1 - ((y1 - previewY) / 2) : previewY - ((previewY - y1) / 2)
        text(k, halfX, halfY);
      }
      // if the new position is outside the canvas plus some margin, skip this angle
      if (
        previewX > (width - (margin))
        ||
        previewX < (0 + (margin))
        ||
        previewY > (width - (margin / 4))
        ||
        previewY < (0 + (margin))
      ) {
        if (debug) {
          console.log(`new point ${previewX},${previewY} is too close`)
        }
        continue
      }
      // if there are no previous directions to compare it with, use this one
      if (previousAng == undefined) {
        foundAng = true
        break
      }

      var isWithinDistance = checkDistance(ang, previousAng, _angleDistanceMin)
      if (!isWithinDistance) {
        // console.log(`not within distance(${ang} and ${previousAng} are not within ${_angleDistanceMin})`)
        break
      }

      foundAng = true
      break
    }
    return { foundAng, ang, attempts }
  }

  function getAngleDifference(ang1, ang2) {
    var distance = Math.abs(modulo(ang1, 360) - modulo(ang2, 360))
    distance = Math.min(distance, 360 - distance)
    return distance
  }

  function checkDistance(ang1, ang2, _angleDistanceMin) {
    var distance = getAngleDifference(ang1, ang2)
    if (debug) {
      console.log(`distance between ${ang1} and ${ang2} is ${distance} (min ${_angleDistanceMin})`)
    }
    return distance <= _angleDistanceMin
  }

  function modulo(x, y) {
    var xPrime = x;
    while (xPrime < 0) {
      xPrime += y; // ASSUMES y > 0
    }
    return xPrime % y;
  }
</script>

</html>